**ASSUMPTIONS**


G(F(day & X day & X X day))
G(F(night & X night & X X night))

G((day & !night) | (night & !day))


**GUARANTEES**

# Strict Ordered Patrolling Location r3, r4 During Context Night

# G(F(r3 & F(r4)))
G(F((night & active & r3) & F(night & active & r4)))

# (!(r4) U r3)
(!(night & active) | !r4) U ((night & active) & r3)

# G(((r4) -> (X((!(r4) U r3)))))
G(!(night & active) | (r4 -> X(!(night & active) U ((!(night & active) | !r4) U ((night & active) & r3)))))

# G(((r3) -> (X((!(r3) U r4)))))
G(!(night & active) | (r3 -> X(!(night & active) U ((!(night & active) | !r3) U ((night & active) & r4)))))

# Every day there is some activity
G((night & X day) -> X (!night U active))

# Every night there is some activity
G((day & X night) -> X (!day U active))

# The transition controller should act immediately
G((day & X night & X ! active) -> X r5)
G((night & X day & X ! active) -> X r5)
G((r5 & night & X night) -> (X ! r5))
G((r5 & day & X day) -> (X ! r5))

# Strict Ordered Patrolling Location r1, r2 During Context Day

# G(F(r1 & F(r2)))
G(F((day & active & r1) & F(day & active & r2)))

# (!(r2) U r1)
(!(day & active) | !r2) U ((day & active) & r1)

# G(((r2) -> (X((!(r2) U r1)))))
G(!(day & active) | (r2 -> X(!(day & active) U ((!(day & active) | !r2) U ((day & active) & r1)))))

# G(((r1) -> (X((!(r1) U r2)))))
G(!(day & active) | (r1 -> X(!(day & active) U ((!(day & active) | !r1) U ((day & active) & r2)))))



# Active is false only when transitioning
# G(r5 -> ! active)

# Active only for one step (forcing to only visit r5 and change context)
# G(!active -> X active)

# Deactivates when inactive
G((active & X!active) -> ((day & X night) | (night & X day)))

G(F(active))

G((day & active) -> (r1 | r2))
G((night & active) -> (r3 | r4))


# Mutex and adjacency Rules
G((r4 & ! (r3) & ! (r1) & ! (r2) & ! (r5)) | (r1 & ! (r4) & ! (r5) & ! (r2) & ! (r3)) | (r5 & ! (r4) & ! (r1) & ! (r2) & ! (r3)) | (r2 & ! (r4) & ! (r5) & ! (r1) & ! (r3)) | (r3 & ! (r4) & ! (r5) & ! (r2) & ! (r1)))
G(((r4) -> (X((r4 | r3 | r5)))))
G(((r5) -> (X((r4 | r5 | r2 | r1 | r3)))))
G(((r2) -> (X((r1 | r2 | r5)))))
G(((r1) -> (X((r1 | r2 | r5)))))
G(((r3) -> (X((r4 | r3 | r5)))))


**INPUTS**

day, night

**OUTPUTS**

r4, r5, r2, r1, r3, active

**END**

